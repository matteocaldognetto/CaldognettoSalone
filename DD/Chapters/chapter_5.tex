\chapter{Implementation, Integration and Test Plan}
\label{ch:Implementation, Integration and Test Plan}

\section{Overview and Implementation Plan}

This chapter describes the implementation strategy, integration approach, and comprehensive testing plan for the Best Bike Paths platform. The development follows a systematic bottom-up methodology that ensures each component is thoroughly validated before integration into the larger system.

The bottom-up implementation strategy begins with the fundamental data layer components and progressively builds toward the user-facing presentation tier. This approach allows development teams to work on independent modules simultaneously while maintaining clear integration checkpoints. Each newly developed module undergoes isolated testing with purpose-built drivers before being integrated into the growing system. Once integrated, the module replaces its corresponding driver and becomes part of a validated subsystem that serves as a foundation for subsequent components.

This incremental integration methodology offers several advantages particularly relevant to the Best Bike Paths architecture. The modular nature of the tRPC-based backend and component-based React frontend naturally supports parallel development across features. Testing occurs on manageable subsystems rather than attempting to validate the entire system at once, making bug identification and resolution more efficient. The clear dependency hierarchy between features ensures that foundational capabilities like authentication and data persistence are solid before building community features like path sharing and obstacle reporting on top of them.

The implementation leverages the monorepo structure to maintain type safety across the frontend-backend boundary throughout development. Drizzle ORM's type-safe database queries ensure that schema changes immediately surface as TypeScript compilation errors in dependent services. The tRPC procedures provide compile-time verification that frontend calls match backend implementations, eliminating an entire class of integration bugs before runtime. This architectural foundation allows the bottom-up strategy to proceed with confidence that type mismatches will be caught during development rather than discovered during integration testing.

\section{Features Identification}

The Best Bike Paths platform functionality decomposes into distinct feature sets that can be implemented and integrated following clear dependency relationships. Each feature builds upon previously implemented capabilities, establishing a natural implementation order that minimizes integration complexity.

\paragraph{[F1] Authentication and Session Management.} This foundational feature set encompasses user registration, login, session creation, and authentication middleware. Every subsequent feature in the platform depends on reliable user identity management, making this the first implementation priority. The authentication system uses Better Auth with session-based cookies for security, implementing password hashing with industry-standard algorithms and secure session token generation. This feature integrates directly with the PostgreSQL database for user credential storage and session persistence, requiring only the data layer to be operational before implementation can begin. The frontend components include registration forms with client-side validation, login interfaces with clear error messaging, and session state management through authentication context providers.

\paragraph{[F2] Trip Recording Infrastructure.} Once users can authenticate, the system must provide the core value proposition of recording cycling trips. This feature set divides into two distinct but related capabilities: manual trip recording and automated trip simulation. The manual recording mode allows users to construct routes by selecting street segments obtained through Overpass API integration, with OSRM calculating distances between waypoints. The automated mode generates simulated trips with realistic route geometries, weather conditions, and obstacle placements for demonstration and testing purposes. Both modes persist trip data including start and end times, distance and duration metrics, route geometries as GeoJSON, and optional weather information. This feature requires authentication to associate trips with users and relies on the database schema for trip, route, and obstacle entities. The implementation includes the Trip Manager service on the backend and Trip Recording components with map visualization on the frontend.

\paragraph{[F3] Map Visualization and Interaction.} The platform's geographic nature demands robust map rendering and interaction capabilities. This feature implements the Leaflet-based map interface that displays trip routes, path geometries, and obstacle locations. Users interact with the map to select waypoints during manual trip construction, view completed trips with rendered routes, and visualize community paths with condition indicators. The map components handle coordinate transformations, zoom level management, marker placement, and polyline rendering for route geometries. This feature depends on trip recording to have data to visualize and integrates with both Overpass for street geometry display and OSRM for route preview during trip construction. The implementation requires careful attention to performance when rendering large route geometries and managing map tile loading efficiently.

\paragraph{[F4] Obstacle Reporting and Verification.} Building on trip recording, this feature enables users to mark obstacles encountered during rides and manage their lifecycle through the verification workflow. During manual trip recording, users can click map locations to place obstacle markers, specifying type and description. Automated trip simulation generates obstacles based on route geometry, starting in PENDING status awaiting user confirmation. The trip detail view displays all obstacles associated with a trip, allowing the owner to transition them through CONFIRMED, REJECTED, or CORRECTED states. This feature requires the Trip Recording infrastructure to exist before implementation since obstacles attach to specific routes within trips. The Obstacle Manager service enforces status lifecycle rules and ownership verification, while the frontend provides intuitive interfaces for obstacle manipulation with clear visual feedback on verification status.

\paragraph{[F5] Path Publishing and Discovery.} This feature transforms personal trips into community-shared paths, enabling the collaborative aspect central to the platform's mission. Users can publish trips that meet quality criteria—having a rating and verified obstacles—converting them into public paths visible on the community map. The publishing process creates path records linked to the trip's street segments through path\_segment relationships, calculating aggregate condition scores from obstacle data. Path discovery allows users to search for routes by geographic area or origin-destination pairs, viewing paths ranked by community ratings and condition assessments. This feature depends on Trip Recording to have content to publish and Obstacle Verification to ensure published paths have validated hazard information. The implementation includes the Path Manager service, path search and ranking algorithms, and discovery interfaces with filtering capabilities.

\paragraph{[F6] Rating and Review System.} The quality of community-contributed paths relies on user feedback mechanisms. This feature allows users to rate trips before publishing, providing the community with quality signals about route desirability. The rating system captures numeric scores and optional textual reviews that surface in path detail views. Aggregate ratings influence path ranking in search results, prioritizing well-regarded routes. This feature integrates with Path Publishing since ratings are required before publication, and enhances Path Discovery by providing sorting and filtering dimensions. The implementation requires extending trip entities with rating storage, creating rating capture interfaces in the trip detail view, and incorporating ratings into the path scoring algorithm within the Aggregation Engine.

\paragraph{[F7] External Service Integration.} Throughout the feature implementations described above, integration with external services provides critical capabilities the platform doesn't implement internally. OSRM integration calculates optimal cycling routes between coordinates, providing realistic distance and duration estimates along with detailed route geometries. Overpass API delivers OpenStreetMap street data for manual route construction, enabling users to search for streets by name and retrieve their precise coordinates. Weather service integration enriches trip records with atmospheric conditions at the time of recording. These integrations require robust error handling since external service availability cannot be guaranteed. The implementation includes adapter services that normalize external API responses, implement retry logic with exponential backoff, and provide graceful degradation when services are unavailable. Circuit breaker patterns prevent cascading failures when dependencies experience extended outages.

\paragraph{[F8] User Profile and Statistics.} Users need visibility into their cycling activity and contributions to the community. This feature provides personal areas displaying trip history, published paths, obstacle reports, and aggregate statistics like total distance cycled and paths contributed. The profile view shows user information and activity summaries, while detailed statistics pages break down metrics by time period and activity type. This feature depends on Trip Recording, Path Publishing, and Obstacle Reporting features to have data to aggregate and display. The implementation includes specialized query functions that efficiently calculate statistics across potentially large datasets, caching mechanisms to avoid repeated expensive computations, and visualization components that present metrics in user-friendly formats.

\section{Integration Strategy}

The integration of system components proceeds systematically from the data persistence layer upward through business logic services to the user interface, following the bottom-up methodology outlined in the implementation overview. Integration begins immediately once the database management system and hosting infrastructure are operational. External service connections are established progressively as features requiring them reach integration.

The foundational integration establishes the database schema and ORM layer. The PostgreSQL instance with PostGIS extension is deployed and configured with connection pooling appropriate for serverless environments. Drizzle ORM integration is validated through migration execution and basic CRUD operations on test data. The schema supporting users, sessions, trips, routes, obstacles, paths, and path segments is created with proper indexes for geospatial queries and foreign key relationships ensuring referential integrity. Testing at this level uses database clients to verify schema correctness, constraint enforcement, and index effectiveness through query analysis. Once validated, the database layer provides the persistence foundation for all subsequent integrations.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.4\linewidth]{Images/bbp - integration f1 data.drawio.png}
        \caption{Database layer integration with Drizzle ORM}
        \label{fig:integration_data}
    \end{center}
\end{figure}

Building on the persistence layer, the authentication system components are integrated next. The Better Auth library is configured with the database connection, implementing user registration with password hashing, login with credential verification, and session creation with secure cookie handling. The authentication middleware is integrated into the Hono HTTP framework, providing request context enrichment with authenticated user information. Testing involves driver programs that invoke registration and login procedures, verifying password hashing produces different outputs for identical passwords, session tokens are cryptographically secure, and session validation correctly accepts valid tokens while rejecting invalid or expired ones. Frontend authentication components are integrated with the backend tRPC procedures, establishing the session management flow that protects subsequent features.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.4\linewidth]{Images/bbp - integration f1 auth.drawio.png}
        \caption{Authentication system integration}
        \label{fig:integration_auth}
    \end{center}
\end{figure}

The Trip Manager service and its associated data access objects are integrated after authentication is validated. This integration includes trip creation procedures that accept manual and simulated collection modes, route addition functions that persist GeoJSON geometries, and obstacle creation with status lifecycle management. External service adapters for OSRM and Overpass are implemented and tested with mock responses before connecting to actual external APIs. Testing drivers invoke trip creation with various data combinations, verify cascade deletes remove associated routes and obstacles when trips are deleted, and confirm GeoJSON storage and retrieval maintains coordinate precision. The frontend trip recording components are integrated incrementally, starting with basic trip information forms, then adding map interaction for route construction, and finally incorporating obstacle marking capabilities.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.4\linewidth]{Images/bbp - integration f2 trips.drawio.png}
        \caption{Trip recording feature integration}
        \label{fig:integration_trips}
    \end{center}
\end{figure}

Map visualization components integrate alongside trip recording since route display is essential for user verification of constructed trips. The Leaflet library is configured with appropriate tile providers and the map container is embedded in trip recording and detail views. Route rendering functions convert GeoJSON LineStrings into Leaflet polylines with styling that indicates route quality. Marker placement for obstacles uses custom icons that visually distinguish between PENDING, CONFIRMED, and other status values. Testing involves rendering various route geometries including edge cases like single-point routes and very long routes with thousands of coordinates, verifying zoom and pan operations maintain performance, and confirming marker click events trigger appropriate detail displays.

The obstacle verification workflow integrates after trip recording and display are operational. The trip detail view is extended with obstacle lists showing current status and providing actions for confirmation, rejection, and correction. The Obstacle Manager service implements state transition validation, rejecting invalid transitions and ensuring only trip owners can modify obstacle status. Testing validates that status changes persist correctly, transition rules are enforced preventing EXPIRED obstacles from returning to PENDING, and ownership verification prevents users from modifying obstacles they don't own. Integration testing covers the complete flow from trip creation with simulated obstacles through user verification to final CONFIRMED or REJECTED states.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.55\linewidth]{Images/bbp - integration f4 obstacles.drawio.png}
        \caption{Obstacle verification integration}
        \label{fig:integration_obstacles}
    \end{center}
\end{figure}

Path publishing functionality integrates once trip recording and obstacle verification are reliable. The Path Manager service implements the publishing logic that validates trip eligibility, creates path records, and establishes path segment relationships linking paths to constituent streets. The Aggregation Engine integrates to calculate path scores from obstacle data and user ratings. Testing verifies published trips create corresponding path records, path segments correctly reference street segments from routes, trips already published cannot be republished, and deleting a path cascades to remove path segments while preserving the original trip. Frontend integration includes publishing buttons in the trip list view, confirmation dialogs explaining publishing consequences, and validation error messages when requirements aren't met.

Path discovery features integrate after publishing provides content to discover. The path search procedure implements spatial queries using PostGIS to find paths within geographic bounds or along specified corridors. Search results include aggregate ratings, condition scores from the Aggregation Engine, and summary statistics like total distance and elevation gain. The frontend discovery interface provides map-based search where users define areas of interest, list views ranking paths by relevance, and detail views showing complete path information with review summaries. Testing validates search returns appropriate results for various geographic queries, ranking algorithms surface high-quality paths, and detail views correctly display path geometry and obstacles.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.6\linewidth]{Images/bbp - integration f5 publishing.drawio.png}
        \caption{Path publishing and discovery integration}
        \label{fig:integration_publishing}
    \end{center}
\end{figure}

Rating and review features integrate alongside publishing since they're required for publication. The trip detail view gains rating interfaces allowing numeric score selection and optional review text entry. The rating data persists with trip records and appears in path detail views after publication. The Aggregation Engine incorporates ratings into path scoring algorithms, weighting recent ratings more heavily than older ones and considering rating distribution to identify controversial paths. Testing confirms ratings persist correctly, aggregate calculations accurately reflect individual ratings, and published paths display rating summaries that update when new ratings are added.

User profile and statistics features integrate after the core trip and path workflows are operational, since they aggregate data from these features. The profile view queries for user trips, published paths, and obstacle reports, presenting summaries with key metrics. Statistics calculations efficiently aggregate data across potentially thousands of trips using database indexes and caching to avoid performance degradation. The personal trips area integrates trip listing, detail viewing, and management actions like deletion and publishing. Testing validates statistics calculations match expected values for test data sets, profile views efficiently load even for very active users, and deletion operations properly cascade through related data.

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=0.6\linewidth]{Images/bbp - integration final.drawio.png}
        \caption{Complete integrated system}
        \label{fig:integration_final}
    \end{center}
\end{figure}

External service integrations occur progressively as features requiring them reach implementation. OSRM integration begins during trip recording implementation, initially using mock responses for testing before connecting to the actual public OSRM instance or a self-hosted deployment. Overpass integration follows a similar pattern, with mock street data enabling frontend development before live API integration. Weather service integration occurs late since it's non-critical, allowing implementation to focus on core features before adding contextual enhancements. Each external integration includes error handling that gracefully degrades functionality when services are unavailable, preventing external dependencies from blocking platform operation.

Throughout the integration process, the tRPC procedures serve as clear integration boundaries between frontend and backend. The type safety provided by shared TypeScript definitions ensures that frontend components always call backend procedures with correct parameter types and handle responses appropriately. This compile-time verification catches integration errors immediately during development rather than discovering them during runtime testing. The TanStack Query integration on the frontend provides caching and optimistic updates that improve perceived performance and reduce unnecessary backend requests, while maintaining consistency when data changes.

\section{System Testing Strategy}

System testing is used to ensure that each newly developed component works correctly on its own and that, once integrated, the overall platform still satisfies the requirements described in the RASD.

Before integration, each backend service and key frontend module is validated in isolation using dedicated drivers (i.e., small test clients that invoke the component’s public interfaces). After integration, tests are repeated with new drivers to verify correct interactions between modules and to ensure that end-to-end workflows remain consistent.

The strategy follows a layered approach (many fast unit/component tests, fewer integration tests, and a limited set of end-to-end tests for critical user journeys). For components with stateful lifecycles (e.g., obstacle verification), state-transition test cases are used to validate both valid and invalid status changes. 

The following test types are applied:
    \begin{itemize}
        \item \textbf{Component (Unit) Testing:} Validates business logic and edge cases in isolation, using drivers and test doubles for external dependencies.
        \item \textbf{Integration Testing:} Verifies that subsystems cooperate correctly and that data is stored/retrieved consistently.
        \item \textbf{Functional (End-to-End) Testing:} Checks that main workflows (registration, trip recording, obstacle reporting/verification, path discovery) match the RASD scenarios from the user perspective.
        \item \textbf{Load and Performance Testing:} Measures responsiveness and stability under expected traffic, identifying bottlenecks and capacity limits.
        \item \textbf{Stress Testing:} Pushes the system beyond normal conditions to observe failure behavior and recovery capabilities.
        \item \textbf{Security and UI Testing:} Ensures authentication/authorization rules are enforced and the web interface remains usable and accessible across common environments.
    \end{itemize}

Most automated tests run continuously in CI to provide rapid feedback, while broader end-to-end, performance, and security checks are executed on dedicated environments before releases. 